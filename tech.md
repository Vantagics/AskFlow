# å‘é‡æ£€ç´¢æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯æ–‡æ¡?

## æ¦‚è¿°

æœ¬æ–‡æ¡£è®°å½•äº† Askflow RAG ç³»ç»Ÿä¸­å‘é‡æ£€ç´¢æ¨¡å—çš„å…¨éƒ¨æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯æˆæœã€‚ä¼˜åŒ–è¦†ç›–å››ä¸ªå±‚çº§å…± 20 é¡¹æŠ€æœ¯ï¼Œç›®æ ‡æ˜¯åœ¨æœ‰é™ç¡¬ä»¶æ¡ä»¶ä¸‹å®ç°å…¨é€Ÿè¿è¡Œã€?

| å±‚çº§ | æ¶‰åŠæ–‡ä»¶ | ä¼˜åŒ–é¡¹æ•° | æ ¸å¿ƒæ‰‹æ®µ |
|------|---------|---------|---------|
| æŒ‡ä»¤çº?| `simd_amd64.s`, `simd_amd64.go`, `simd_arm64.s`, `simd_arm64.go`, `simd_generic.go` | 6 é¡?| AVX-512 / AVX2+FMA / SSE / ARM NEON+FMLA / SQRTSD ç¡¬ä»¶æŒ‡ä»¤ |
| å‘é‡å­˜å‚¨å±?| `store.go` | 9 é¡?| Arena å†…å­˜å¸ƒå±€ã€åˆ†åŒºç´¢å¼•ã€å†…è”å †æ’åºã€ç¼“å­?|
| æŸ¥è¯¢å¼•æ“å±?| `engine.go` | 2 é¡?| Embedding ç¼“å­˜ã€æ‰¹é‡?SQL |
| åºåˆ—åŒ–å±‚ | `serialize.go` | 2 é¡?| Float32 ç›´æ¥ååºåˆ—åŒ–ã€å¿«é€Ÿè·¯å¾„ååºåˆ—åŒ?|
| æ¶æ„å±?| `sqlite-vec/` | 1 é¡?| ç‹¬ç«‹ Go module å°è£…ï¼Œè·¨é¡¹ç›®å¤ç”¨ |

### ä¼˜åŒ–å±‚æ¬¡æ¶æ„

```
ç”¨æˆ·æŸ¥è¯¢
  â”?
  â–?
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”?
â”? æŸ¥è¯¢å¼•æ“å±?(engine.go)                          â”?
â”? â”œâ”€â”€ Embedding API ç¼“å­˜ (512æ? 10min TTL)       â”?
â”? â””â”€â”€ æ‰¹é‡ SQL æŸ¥è¯¢ (IN clause)                   â”?
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”?
                   â”?queryVector []float64
                   â–?
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”?
â”? å‘é‡å­˜å‚¨å±?(store.go)                            â”?
â”? â”œâ”€â”€ LRU æŸ¥è¯¢ç¼“å­˜ (FNV-1a hash, 256æ?           â”?
â”? â”œâ”€â”€ Product åˆ†åŒºç´¢å¼• â†?ç¼©å°æœç´¢èŒƒå›´              â”?
â”? â”œâ”€â”€ è¿ç»­å†…å­˜ Arena â†?CPU cache å‹å¥½              â”?
â”? â”œâ”€â”€ è‡ªé€‚åº”å¹¶å‘ Worker                            â”?
â”? â”œâ”€â”€ Per-Worker Min-Heap Top-K                   â”?
â”? â”?                                              â”?
â”? â”? â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”? â”?
â”? â”? â”? æŒ‡ä»¤çº?(simd_*.s)                       â”? â”?
â”? â”? â”? â”œâ”€â”€ AVX-512: 64 floats/iter, 8.8x     â”? â”?
â”? â”? â”? â”œâ”€â”€ AVX2+FMA: 32 floats/iter, 8.6x    â”? â”?
â”? â”? â”? â”œâ”€â”€ ARM NEON: 16 floats/iter, ~4x      â”? â”?
â”? â”? â”? â”œâ”€â”€ SSE: 16 floats/iter, ~2x           â”? â”?
â”? â”? â”? â”œâ”€â”€ Pure Go 8-way: å›é€€                 â”? â”?
â”? â”? â”? â””â”€â”€ SQRTSD: ç¡¬ä»¶å¹³æ–¹æ ?                  â”? â”?
â”? â”? â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”? â”?
â”? â””â”€â”€ é¢„è®¡ç®?Bigrams (TextSearch)                  â”?
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”?
                   â”?embeddingBytes
                   â–?
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”?
â”? åºåˆ—åŒ–å±‚ (serialize.go)                          â”?
â”? â””â”€â”€ Float32 ç›´æ¥ååºåˆ—åŒ– (é›¶ä¸­é—´è½¬æ?             â”?
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”?
```

---

## ä¸€ã€å‘é‡å­˜å‚¨å±‚ä¼˜åŒ–

### 1.1 è¿ç»­å†…å­˜å‘é‡ Arena

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* åŸå®ç°ä¸­æ¯ä¸ª `cachedChunk` æŒæœ‰ç‹¬ç«‹çš?`[]float64` åˆ‡ç‰‡ï¼ŒN ä¸?chunk æ„å‘³ç€ N æ¬¡ç‹¬ç«‹å †åˆ†é…ã€‚æœç´¢æ—¶ CPU éœ€è¦è·Ÿéš?N ä¸ªæŒ‡é’ˆè·³è½¬åˆ°ä¸åŒçš„å†…å­˜åœ°å€è¯»å–å‘é‡æ•°æ®ï¼Œå¯¼è‡?L1/L2 cache å‘½ä¸­ç‡æä½ã€?

**æ–¹æ¡ˆï¼?* å¼•å…¥ `vectorArena` ç»“æ„ï¼Œå°†æ‰€æœ‰å‘é‡å­˜å‚¨åœ¨ä¸€ä¸ªè¿ç»­çš„ `[]float32` å¤§æ•°ç»„ä¸­ã€‚æ¯ä¸?chunk çš„å‘é‡é€šè¿‡ `index * dim` è®¡ç®—åç§»é‡ç›´æ¥å®šä½ï¼Œæ— éœ€æŒ‡é’ˆé—´æ¥å¯»å€ã€?

```go
type vectorArena struct {
    data []float32  // æ‰€æœ‰å‘é‡è¿ç»­å­˜å‚?
    dim  int        // å‘é‡ç»´åº¦
}

func (a *vectorArena) getVector(idx int) []float32 {
    start := idx * a.dim
    return a.data[start : start+a.dim]
}
```

**æ•ˆæœï¼?*
- 10K ä¸?1536 ç»´å‘é‡ï¼š~60MB è¿ç»­å†…å­˜ vs 10K æ¬¡éšæœºå †æŒ‡é’ˆè·³è½¬
- CPU é¢„å–å™¨å¯ä»¥æœ‰æ•ˆé¢„æµ‹é¡ºåºè®¿é—®æ¨¡å¼ï¼ŒL1/L2 cache å‘½ä¸­ç‡å¤§å¹…æå?
- æ¶ˆé™¤äº?N ä¸ªç‹¬ç«?slice headerï¼ˆæ¯ä¸?24 å­—èŠ‚ï¼‰çš„å†…å­˜å¼€é”€

### 1.2 Float32 å†…å­˜è¡¨ç¤º

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`, `internal/vectorstore/serialize.go`

**é—®é¢˜ï¼?* åŸå®ç°åœ¨ååºåˆ—åŒ–æ—¶å°† float32 æ•°æ®è½¬å› float64 å­˜å…¥å†…å­˜ï¼Œç™½ç™½æµªè´?2 å€?RAMã€‚Embedding æ¨¡å‹çš„ç²¾åº¦æœ¬èº«å°±æ˜?float32 çº§åˆ«ï¼Œfloat64 ä¸ä¼šå¸¦æ¥ä»»ä½•æ£€ç´¢è´¨é‡æå‡ã€?

**æ–¹æ¡ˆï¼?*
- ç¼“å­˜ä¸­ç»Ÿä¸€ä½¿ç”¨ `[]float32` å­˜å‚¨å‘é‡
- æ–°å¢ `DeserializeVectorF32()` ç›´æ¥ååºåˆ—åŒ–ä¸?float32ï¼Œé¿å…?float64 ä¸­é—´è½¬æ¢
- æœç´¢æ—¶å°†æŸ¥è¯¢å‘é‡ä¸€æ¬¡æ€§è½¬ä¸?float32 åè¿›è¡Œè®¡ç®?

```go
// æ–°å¢ï¼šç›´æ¥ååºåˆ—åŒ–ä¸º float32
func DeserializeVectorF32(data []byte) []float32

// æœç´¢æ—¶ä¸€æ¬¡æ€§è½¬æ?
queryF32 := toFloat32(queryVector)
```

**æ•ˆæœï¼?*
- å†…å­˜å ç”¨å‡åŠï¼?536 ç»?Ã— 10K chunks = 60MBï¼ˆfloat32ï¼‰vs 120MBï¼ˆfloat64ï¼?
- å‡å°‘å†…å­˜å¸¦å®½å‹åŠ›ï¼Œé—´æ¥æå?CPU è®¡ç®—åå

### 1.3 Product åˆ†åŒºç´¢å¼•

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* åŸå®ç°åœ¨æœç´¢æ—¶éå†æ‰€æœ?chunkï¼Œé€šè¿‡ `if productID != "" && c.productID != productID` é€ä¸ªè¿‡æ»¤ã€‚å¤šäº§å“åœºæ™¯ä¸‹ï¼Œå¤§é‡ CPU æ—¶é—´æµªè´¹åœ¨è®¡ç®—ä¸ç›¸å…³äº§å“çš„å‘é‡ç›¸ä¼¼åº¦ä¸Šã€?

**æ–¹æ¡ˆï¼?* å¼•å…¥ `productIndex map[string][]int`ï¼Œåœ¨æ•°æ®å…¥åº“æ—¶æŒ‰ productID é¢„åˆ†åŒºã€‚æœç´¢æ—¶ç›´æ¥å–å‡ºç›®æ ‡äº§å“ + å…¬å…±åº“çš„ç´¢å¼•åˆ—è¡¨ï¼Œåªéå†ç›¸å…³æ•°æ®ã€?

```go
productIndex map[string][]int  // productID -> []chunkIndex

func (s *SQLiteVectorStore) getRelevantIndices(productID string) []int {
    if productID == "" {
        return allIndices
    }
    // åªè¿”å›ç›®æ ‡äº§å“?+ å…¬å…±åº“çš„ç´¢å¼•
    return append(s.productIndex[productID], s.productIndex[""]...)
}
```

**æ•ˆæœï¼?*
- 5 ä¸ªäº§å“å„ 2K chunks çš„åœºæ™¯ï¼šæœç´¢èŒƒå›´ä»?10K é™åˆ° ~4Kï¼ˆç›®æ ‡äº§å“?2K + å…¬å…±åº“ï¼‰
- å®Œå…¨æ¶ˆé™¤äº†ä¸ç›¸å…³äº§å“çš„ç›¸ä¼¼åº¦è®¡ç®—å¼€é”€

### 1.4 8-way å¾ªç¯å±•å¼€ Dot Product

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* ç®€å•çš„é€å…ƒç´ å¾ªç¯å­˜åœ¨å¾ªç¯ä¾èµ–é“¾ï¼ˆæ¯æ¬¡è¿­ä»£çš„ç´¯åŠ ä¾èµ–ä¸Šä¸€æ¬¡çš„ç»“æœï¼‰ï¼ŒCPU çš„æŒ‡ä»¤çº§å¹¶è¡Œåº¦ï¼ˆILPï¼‰æ— æ³•å……åˆ†åˆ©ç”¨ã€?

**æ–¹æ¡ˆï¼?* ä½¿ç”¨ 8 ä¸ªç‹¬ç«‹ç´¯åŠ å™¨è¿›è¡Œå¾ªç¯å±•å¼€ï¼Œæ‰“ç ´ä¾èµ–é“¾ï¼Œè®© CPU æµæ°´çº¿å¯ä»¥åŒæ—¶æ‰§è¡Œå¤šæ¡ä¹˜åŠ æŒ‡ä»¤ã€?

```go
func dotProductF32x8(a, b []float32) float32 {
    var s0, s1, s2, s3, s4, s5, s6, s7 float32
    for ; i <= n-8; i += 8 {
        s0 += a[i] * b[i]
        s1 += a[i+1] * b[i+1]
        // ... s2-s7
    }
    return (s0 + s1 + s2 + s3) + (s4 + s5 + s6 + s7)
}
```

**æ•ˆæœï¼?*
- 1536 ç»´å‘é‡ï¼š192 æ¬¡è¿­ä»£ï¼ˆvs åŸæ¥ 1536 æ¬¡ï¼‰
- 8 ä¸ªç‹¬ç«‹ç´¯åŠ å™¨æ¶ˆé™¤äº†å¾ªç¯æºå¸¦ä¾èµ–ï¼ŒCPU è¶…æ ‡é‡æ‰§è¡Œå•å…ƒå¯ä»¥å¹¶è¡Œå¤„ç?
- Norm è®¡ç®—åŒæ ·é‡‡ç”¨ 8-way å±•å¼€

### 1.5 Per-Worker å†…è” Min-Heap Top-K

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* åŸå®ç°æ¯ä¸?worker æ”¶é›†æ‰€æœ‰è¶…è¿‡é˜ˆå€¼çš„ç»“æœï¼Œæœ€åå…¨é‡æ’åºå– Top-Kã€‚å½“æ•°æ®é‡å¤§ã€é˜ˆå€¼ä½æ—¶ï¼Œå¯èƒ½æ”¶é›†æ•°åƒä¸ªç»“æœå†æ’åºï¼Œæµªè´¹å¤§é‡å†…å­˜å’Œ CPUã€?

**æ–¹æ¡ˆï¼?* æ¯ä¸ª worker ç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸º K çš„æœ€å°å †ï¼Œåªä¿ç•™å½“å‰æœ€å¥½çš„ K ä¸ªç»“æœã€‚æ–°ç»“æœåªæœ‰æ¯”å †é¡¶ï¼ˆæœ€å·®çš„ Top-K ç»“æœï¼‰æ›´å¥½æ—¶æ‰å…¥å †ã€‚å †æ“ä½œå®Œå…¨å†…è”ï¼ˆæ‰‹å†?sift-up/sift-downï¼‰ï¼Œé¿å… `container/heap` çš?`interface{}` è£…ç®±å¼€é”€å’Œé—´æ¥è°ƒç”¨ã€‚æœ€ç»ˆåˆå¹¶æ—¶åªéœ€å¤„ç† `numWorkers Ã— K` ä¸ªå…ƒç´ ã€?

```go
// æ¯ä¸ª worker å†…éƒ¨ â€?å†…è” min-heapï¼Œé›¶ interface{} åˆ†é…
h := make([]scoredItem, 0, topK+1)
hLen := 0

if hLen < topK {
    h = append(h, scoredItem{score: score, idx: idx})
    hLen++
    // å†…è” sift-up
    i := hLen - 1
    for i > 0 {
        parent := (i - 1) / 2
        if h[parent].score <= h[i].score { break }
        h[parent], h[i] = h[i], h[parent]
        i = parent
    }
} else if score > h[0].score {
    h[0] = scoredItem{score: score, idx: idx}
    // å†…è” sift-down
    i := 0
    for {
        left := 2*i + 1
        if left >= hLen { break }
        smallest := left
        right := left + 1
        if right < hLen && h[right].score < h[left].score { smallest = right }
        if h[i].score <= h[smallest].score { break }
        h[i], h[smallest] = h[smallest], h[i]
        i = smallest
    }
}
```

**æ•ˆæœï¼?*
- å†…å­˜ï¼šæ¯ä¸?worker æœ€å¤šæŒæœ?K ä¸ªç»“æœï¼ˆé€šå¸¸ K=5ï¼‰ï¼Œè€Œéæ‰€æœ‰è¶…é˜ˆå€¼ç»“æ?
- æ—¶é—´ï¼šO(N log K) vs O(N + M log M)ï¼Œå…¶ä¸?M æ˜¯è¶…é˜ˆå€¼ç»“æœæ•°
- åˆå¹¶é˜¶æ®µï¼šå¤„ç?`numWorkers Ã— K` ä¸ªå…ƒç´ ï¼ˆé€šå¸¸ < 50ï¼‰ï¼Œè€Œéæ•°åƒä¸?
- å†…è”å †æ“ä½œæ¶ˆé™¤äº† `container/heap` çš?`interface{}` è£…ç®±/æ‹†ç®±å’Œè™šå‡½æ•°è°ƒç”¨å¼€é”€

### 1.6 è‡ªé€‚åº” Worker æ•°é‡

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* åŸå®ç°å›ºå®šä½¿ç”?`runtime.NumCPU()` ä¸?goroutineï¼Œå°æ•°æ®é›†æ—¶ goroutine åˆ›å»ºå’Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€åè€Œè¶…è¿‡äº†å¹¶è¡Œæ”¶ç›Šã€?

**æ–¹æ¡ˆï¼?* å¼•å…¥ `minWorkersThreshold = 500`ï¼Œæ ¹æ®æ•°æ®é‡åŠ¨æ€è°ƒæ•?worker æ•°é‡ã€?

```go
func adaptiveWorkers(n int) int {
    if n < 500 { return 1 }
    w := n / 500
    if w > runtime.NumCPU() { w = runtime.NumCPU() }
    return w
}
```

**æ•ˆæœï¼?*
- < 500 æ¡æ•°æ®ï¼šå•çº¿ç¨‹æ‰§è¡Œï¼Œé¿å… goroutine å¼€é”€
- 500-4000 æ¡ï¼š1-8 ä¸?workerï¼ŒæŒ‰éœ€æ‰©å±•
- > 4000 æ¡ï¼šä½¿ç”¨å…¨éƒ¨ CPU æ ¸å¿ƒ

### 1.7 FNV-1a å¿«é€Ÿç¼“å­˜å“ˆå¸?

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* å?LRU ç¼“å­˜ä½¿ç”¨ `fmt.Sprintf("%x", queryVector[:4])` ç”Ÿæˆ cache keyï¼Œæ¯æ¬¡æœç´¢éƒ½è¦åšå­—ç¬¦ä¸²æ ¼å¼åŒ–å’Œå†…å­˜åˆ†é…ã€?

**æ–¹æ¡ˆï¼?* æ”¹ç”¨ FNV-1a æ•´æ•°å“ˆå¸Œï¼Œç›´æ¥å¯¹æŸ¥è¯¢å‘é‡çš„å‰ 8 ä¸?float32 å€?+ topK + threshold + productID è®¡ç®— uint64 å“ˆå¸Œå€¼ã€?

```go
func hashQueryVector(qv []float32, topK int, threshold float64, productID string) uint64 {
    h := uint64(14695981039346656037) // FNV offset
    for i := 0; i < min(8, len(qv)); i++ {
        bits := math.Float32bits(qv[i])
        h ^= uint64(bits)
        h *= 1099511628211 // FNV prime
    }
    // ... hash topK, threshold, productID
    return h
}
```

**æ•ˆæœï¼?*
- é›¶å†…å­˜åˆ†é…ï¼ˆvs fmt.Sprintf çš„å­—ç¬¦ä¸²åˆ†é…ï¼?
- çº¯æ•´æ•°è¿ç®—ï¼Œæ¯”å­—ç¬¦ä¸²å“ˆå¸Œå¿«ä¸€ä¸ªæ•°é‡çº§
- cache key ç±»å‹ä»?`string` æ”¹ä¸º `uint64`ï¼Œmap æŸ¥æ‰¾æ›´å¿«

### 1.8 LRU æŸ¥è¯¢ç»“æœç¼“å­˜

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* ç›¸åŒçš„æŸ¥è¯¢å‘é‡?+ å‚æ•°ç»„åˆä¼šé‡å¤æ‰§è¡Œå®Œæ•´çš„ç›¸ä¼¼åº¦æœç´¢ã€?

**æ–¹æ¡ˆï¼?* 256 æ¡å®¹é‡ã€? åˆ†é’Ÿ TTL çš?LRU ç¼“å­˜ã€‚æ•°æ®å˜æ›´ï¼ˆStore/Deleteï¼‰æ—¶è‡ªåŠ¨å¤±æ•ˆã€?

**æ•ˆæœï¼?*
- é‡å¤æŸ¥è¯¢ç›´æ¥è¿”å›ï¼Œé›¶è®¡ç®—å¼€é”€
- è‡ªåŠ¨å¤±æ•ˆä¿è¯æ•°æ®ä¸€è‡´æ€?

### 1.9 é¢„è®¡ç®?Text Bigrams

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* TextSearchï¼ˆLevel 1 æ–‡æœ¬åŒ¹é…ï¼‰æ¯æ¬¡æŸ¥è¯¢éƒ½å¯¹æ¯ä¸?chunk é‡æ–°è®¡ç®—å­—ç¬¦ bigramsï¼Œå¤æ‚åº¦ O(N Ã— M)ï¼Œå…¶ä¸?M æ˜¯å¹³å?chunk é•¿åº¦ã€?

**æ–¹æ¡ˆï¼?* åœ¨æ•°æ®å…¥åº“æ—¶é¢„è®¡ç®—æ¯ä¸?chunk çš?`textLower` å’?`bigrams`ï¼Œå­˜å…?`chunkMeta`ã€‚TextSearch åªéœ€è®¡ç®—æŸ¥è¯¢çš?bigramsï¼ˆä¸€æ¬¡ï¼‰ï¼Œç„¶åå¯¹æ¯ä¸ª chunk å?map æŸ¥æ‰¾ã€?

```go
type chunkMeta struct {
    // ...
    textLower string          // é¢„è®¡ç®—çš„å°å†™æ–‡æœ¬
    bigrams   map[string]bool // é¢„è®¡ç®—çš„å­—ç¬¦ bigrams
}
```

**æ•ˆæœï¼?*
- TextSearch ä»?O(N Ã— M) é™åˆ° O(N Ã— |query_bigrams|)
- æŸ¥è¯¢ bigrams é€šå¸¸åªæœ‰ 10-30 ä¸ªï¼Œè€?chunk bigrams å¯èƒ½æœ‰æ•°ç™¾ä¸ª

---

## äºŒã€æŸ¥è¯¢å¼•æ“å±‚ä¼˜åŒ–

### 2.1 Embedding API ç»“æœç¼“å­˜

**æ–‡ä»¶ï¼?* `internal/query/engine.go`

**é—®é¢˜ï¼?* ç›¸åŒé—®é¢˜é‡å¤è°ƒç”¨ embedding APIï¼Œæ¯æ¬¡éƒ½äº§ç”Ÿç½‘ç»œå»¶è¿Ÿï¼ˆé€šå¸¸ 100-500msï¼‰ã€‚åœ¨ 3-Level åŒ¹é…æµç¨‹ä¸­ï¼ŒLevel 2 å’?Level 3 å¯èƒ½å¯¹åŒä¸€é—®é¢˜é‡å¤è°ƒç”¨ Embedã€?

**æ–¹æ¡ˆï¼?* åœ?QueryEngine ä¸­æ–°å¢?`embeddingCache`ï¼?12 æ¡å®¹é‡ï¼Œ10 åˆ†é’Ÿ TTLï¼‰ï¼Œæ‰€æœ?Embed è°ƒç”¨é€šè¿‡ `cachedEmbed()` åŒ…è£…ã€?

```go
type embeddingCache struct {
    entries map[string]embeddingCacheEntry  // text -> vector
    maxSize int
    ttl     time.Duration
}

func (qe *QueryEngine) cachedEmbed(text string, es embedding.EmbeddingService) ([]float64, error) {
    if vec, ok := qe.embedCache.get(text); ok {
        return vec, nil  // ç¼“å­˜å‘½ä¸­ï¼Œè·³è¿?API è°ƒç”¨
    }
    vec, err := es.Embed(text)
    if err != nil { return nil, err }
    qe.embedCache.put(text, vec)
    return vec, nil
}
```

**æ•ˆæœï¼?*
- é‡å¤é—®é¢˜é›?API å»¶è¿Ÿï¼ˆä» ~200ms é™åˆ° ~0msï¼?
- åŒä¸€æŸ¥è¯¢åœ?Level 2 â†?Level 3 æµè½¬æ—¶ä¸ä¼šé‡å¤è°ƒç”?API
- åœ¨ç¡¬ä»¶æœ‰é™çš„åœºæ™¯ä¸‹ï¼Œå‡å°‘ç½‘ç»œ IO æ˜¯æœ€å¤§çš„å»¶è¿Ÿä¼˜åŒ–

### 2.2 æ‰¹é‡ SQL æŸ¥è¯¢è§†é¢‘æ—¶é—´ä¿¡æ¯

**æ–‡ä»¶ï¼?* `internal/query/engine.go`

**é—®é¢˜ï¼?* `enrichVideoTimeInfo` å¯¹æ¯ä¸ªæœç´¢ç»“æœé€æ¡æ‰§è¡Œ `QueryRow`ï¼ŒN ä¸ªç»“æœäº§ç”?N æ¬?SQLite æŸ¥è¯¢ï¼Œæ¯æ¬¡éƒ½æœ‰é”è·å–å’?IO å¼€é”€ã€?

**æ–¹æ¡ˆï¼?* æ”¹ä¸ºå•æ¬¡ `WHERE chunk_id IN (?,?,...)` æ‰¹é‡æŸ¥è¯¢ã€?

```go
// ä¹‹å‰ï¼šN æ¬¡æŸ¥è¯?
for i, r := range results {
    db.QueryRow(`SELECT ... WHERE chunk_id = ?`, chunkID)
}

// ä¹‹åï¼? æ¬¡æŸ¥è¯?
query := `SELECT chunk_id, start_time, end_time FROM video_segments
          WHERE chunk_id IN (?,?,?,...)`
rows, _ := db.Query(query, args...)
```

**æ•ˆæœï¼?*
- SQLite é”è·å–ä» N æ¬¡é™åˆ?1 æ¬?
- IO æ“ä½œä»?N æ¬¡é™åˆ?1 æ¬?
- Top-K=5 æ—¶ï¼Œä»?5 æ¬¡æŸ¥è¯¢é™åˆ?1 æ¬?

---

## ä¸‰ã€åºåˆ—åŒ–å±‚ä¼˜åŒ?

### 3.1 Float32 ç›´æ¥ååºåˆ—åŒ–

**æ–‡ä»¶ï¼?* `internal/vectorstore/serialize.go`

**é—®é¢˜ï¼?* å?`DeserializeVector` è¿”å› `[]float64`ï¼Œç¼“å­˜ä½¿ç”?float32 æ—¶éœ€è¦é¢å¤–è½¬æ¢ã€?

**æ–¹æ¡ˆï¼?* æ–°å¢ `DeserializeVectorF32` ç›´æ¥è¿”å› `[]float32`ï¼Œæ”¯æŒä¸ `DeserializeVector` ç›¸åŒçš„æ ¼å¼è‡ªåŠ¨æ£€æµ‹é€»è¾‘ï¼ˆfloat32/float64 legacy å…¼å®¹ï¼‰ã€?

```go
func DeserializeVectorF32(data []byte) []float32     // ç›´æ¥è¾“å‡º float32
func deserializeFloat32Direct(data []byte, n int) []float32  // float32 â†?float32ï¼ˆé›¶ç²¾åº¦æŸå¤±ï¼?
func deserializeFloat64AsF32(data []byte, n int) []float32   // float64 legacy â†?float32
```

**æ•ˆæœï¼?*
- æ¶ˆé™¤äº?float32 â†?float64 â†?float32 çš„æ— æ„ä¹‰è½¬æ¢
- åŠ è½½ç¼“å­˜æ—¶å‡å°‘ä¸€åŠçš„ä¸´æ—¶å†…å­˜åˆ†é…

### 3.2 å¿«é€Ÿè·¯å¾„ååºåˆ—åŒ?(DeserializeVectorF32Unsafe)

**æ–‡ä»¶ï¼?* `internal/vectorstore/store.go`

**é—®é¢˜ï¼?* `DeserializeVectorF32` å¯¹æ‰€æœ‰æ•°æ®éƒ½æ‰§è¡Œæ ¼å¼æ£€æµ‹é€»è¾‘ï¼ˆåˆ¤æ–?float32 vs float64 legacyï¼‰ï¼Œå¯¹äºæ˜ç¡®æ˜?float32 æ ¼å¼çš„æ•°æ®ï¼ˆå­—èŠ‚é•¿åº¦èƒ½è¢« 4 æ•´é™¤ä½†ä¸èƒ½è¢« 8 æ•´é™¤ï¼‰ï¼Œæ ¼å¼æ£€æµ‹æ˜¯å¤šä½™çš„å¼€é”€ã€?

**æ–¹æ¡ˆï¼?* æ–°å¢ `DeserializeVectorF32Unsafe`ï¼Œå¯¹æ— æ­§ä¹‰çš„ float32 æ•°æ®ï¼ˆ`len%8 != 0`ï¼‰ç›´æ¥èµ°å¿«é€Ÿè·¯å¾„ï¼Œè·³è¿‡æ ¼å¼æ£€æµ‹ã€‚æ­§ä¹‰æƒ…å†µå›é€€åˆ°å®‰å…¨çš„ `DeserializeVectorF32`ã€?

```go
func DeserializeVectorF32Unsafe(data []byte) []float32 {
    if len(data)%8 != 0 {
        // æ— æ­§ä¹?float32 â€?ç›´æ¥è§£ç ï¼Œè·³è¿‡æ ¼å¼æ£€æµ?
        n := len(data) / 4
        vec := make([]float32, n)
        for i := 0; i < n; i++ {
            vec[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[i*4:]))
        }
        return vec
    }
    return DeserializeVectorF32(data)  // æ­§ä¹‰æƒ…å†µèµ°å®‰å…¨è·¯å¾?
}
```

**æ•ˆæœï¼?*
- å¯¹æ–°æ ¼å¼æ•°æ®æ¶ˆé™¤äº†æ ¼å¼æ£€æµ‹åˆ†æ”¯å’Œ `isCommonDim` / `looksLikeFloat64Embedding` è°ƒç”¨
- åœ¨æ‰¹é‡åŠ è½½ç¼“å­˜æ—¶å‡å°‘ä¸å¿…è¦çš„æ¡ä»¶åˆ¤æ–­å¼€é”€

---

## å››ã€æ€§èƒ½ä¼°ç®—

### å†…å­˜å ç”¨å¯¹æ¯”ï¼?536 ç»´å‘é‡ï¼‰

| æ•°æ®è§„æ¨¡ | ä¼˜åŒ–å‰?(float64, ç‹¬ç«‹åˆ‡ç‰‡) | ä¼˜åŒ–å?(float32, Arena) | èŠ‚çœ |
|---------|-------------------------|----------------------|------|
| 1K chunks | 12 MB + 1K slice headers | 6 MB è¿ç»­ | ~50% |
| 10K chunks | 120 MB + 10K slice headers | 60 MB è¿ç»­ | ~50% |
| 100K chunks | 1.2 GB + 100K slice headers | 600 MB è¿ç»­ | ~50% |

### å•æ¬¡ Dot Product å»¶è¿Ÿï¼ˆå®æµ‹ï¼ŒAMD Ryzen 7 7840Hï¼?

| å‘é‡ç»´åº¦ | åŸå§‹ Go å¾ªç¯ | 8-way å±•å¼€ | AVX2+FMA | AVX-512 | æ€»åŠ é€Ÿæ¯” |
|---------|-------------|-----------|----------|---------|---------|
| 768 ç»?| ~600 ns | 309 ns | 36 ns | 34.6 ns | **17.3x** |
| 1536 ç»?| ~1200 ns | 593 ns | 70.7 ns | 67.3 ns | **17.8x** |
| 3072 ç»?| ~2400 ns | 1162 ns | 135 ns | 128.9 ns | **18.6x** |

### ç«¯åˆ°ç«¯æœç´¢å»¶è¿Ÿä¼°ç®—ï¼ˆ1536 ç»´ï¼Œ8 æ ?CPUï¼?

| æ•°æ®è§„æ¨¡ | åŸå§‹å®ç° | ç®—æ³•ä¼˜åŒ–å?| + SIMD åŠ é€?(AVX-512) | æ€»åŠ é€Ÿæ¯” |
|---------|---------|-----------|----------------------|---------|
| 1K chunks | ~1.2ms | ~0.2ms | ~0.03ms | **~40x** |
| 10K chunks | ~12ms | ~0.8ms | ~0.1ms | **~120x** |
| 100K chunks | ~120ms | ~6ms | ~0.7ms | **~170x** |

*åŠ é€Ÿæ¥æºå åŠ ï¼šArena è¿ç»­å†…å­˜ + float32 + product åˆ†åŒº + heap top-K + AVX-512/AVX2 SIMD*

*æ³¨ï¼šä»¥ä¸Šä¸ºçº¯è®¡ç®—å»¶è¿Ÿä¼°ç®—ï¼Œä¸å?LRU ç¼“å­˜å‘½ä¸­ï¼ˆå‘½ä¸­æ—¶ä¸?~0msï¼‰å’Œ embedding API å»¶è¿Ÿ*

### API è°ƒç”¨ä¸?IO èŠ‚çœ

| åœºæ™¯ | ä¼˜åŒ–å‰?| ä¼˜åŒ–å?|
|-----|-------|-------|
| é‡å¤é—®é¢˜ embedding | æ¯æ¬¡è°ƒç”¨ API (~200ms) | ç¼“å­˜å‘½ä¸­ (~0ms) |
| Level 2â†? åŒä¸€é—®é¢˜ | 2 æ¬?API è°ƒç”¨ | 1 æ¬?API è°ƒç”¨ |
| è§†é¢‘æ—¶é—´æŸ¥è¯¢ (Top-5) | 5 æ¬?SQL æŸ¥è¯¢ | 1 æ¬?SQL æŸ¥è¯¢ |

---

## äº”ã€å…¨éƒ¨ä¼˜åŒ–æŠ€æœ¯æ€»ç»“

| # | ä¼˜åŒ–é¡?| å±‚çº§ | ç±»å‹ | æ ¸å¿ƒæ”¶ç›Š |
|---|-------|------|------|---------|
| 1 | è¿ç»­å†…å­˜ Arena | å­˜å‚¨ | CPU Cache | L1/L2 å‘½ä¸­ç‡æå‡ï¼Œæ¶ˆé™¤æŒ‡é’ˆè·³è½¬ |
| 2 | Float32 å†…å­˜è¡¨ç¤º | å­˜å‚¨ | å†…å­˜ | RAM å‡åŠï¼Œå¸¦å®½å‹åŠ›é™ä½?|
| 3 | Product åˆ†åŒºç´¢å¼• | å­˜å‚¨ | ç®—æ³• | æœç´¢èŒƒå›´ç¼©å°åˆ°ç›®æ ‡äº§å“?|
| 4 | 8-way å¾ªç¯å±•å¼€ | å­˜å‚¨ | CPU ILP | æ‰“ç ´ä¾èµ–é“¾ï¼Œæµæ°´çº¿å¹¶è¡?|
| 5 | Per-Worker å†…è” Min-Heap | å­˜å‚¨ | ç®—æ³• | O(N log K)ï¼Œå†…è”æ¶ˆé™?interface{} å¼€é”€ |
| 6 | è‡ªé€‚åº” Worker | å­˜å‚¨ | å¹¶å‘ | é¿å…å°æ•°æ®é›† goroutine å¼€é”€ |
| 7 | FNV-1a å¿«é€Ÿå“ˆå¸?| å­˜å‚¨ | å†…å­˜ | é›¶åˆ†é…?cache key è®¡ç®— |
| 8 | LRU æŸ¥è¯¢ç¼“å­˜ | å­˜å‚¨ | ç¼“å­˜ | é‡å¤æŸ¥è¯¢é›¶è®¡ç®?|
| 9 | é¢„è®¡ç®?Bigrams | å­˜å‚¨ | é¢„è®¡ç®?| TextSearch é¿å…é‡å¤è®¡ç®— |
| 10 | Embedding API ç¼“å­˜ | æŸ¥è¯¢ | ç½‘ç»œ IO | é‡å¤é—®é¢˜é›?API å»¶è¿Ÿ |
| 11 | æ‰¹é‡ SQL æŸ¥è¯¢ | æŸ¥è¯¢ | æ•°æ®åº?IO | N æ¬¡æŸ¥è¯¢é™åˆ?1 æ¬?|
| 12 | Float32 ç›´æ¥ååºåˆ—åŒ– | åºåˆ—åŒ?| å†…å­˜ | æ¶ˆé™¤æ— æ„ä¹‰ç²¾åº¦è½¬æ?|
| 13 | å¿«é€Ÿè·¯å¾„ååºåˆ—åŒ?| åºåˆ—åŒ?| åˆ†æ”¯ä¼˜åŒ– | æ— æ­§ä¹?float32 è·³è¿‡æ ¼å¼æ£€æµ?|
| 14 | AVX-512 Dot Product | æŒ‡ä»¤çº?| SIMD | 512-bit FMAï¼?4 floats/iterï¼ŒZen4 å®æµ‹ 8.8x |
| 15 | AVX2+FMA Dot Product | æŒ‡ä»¤çº?| SIMD | 8.6x åŠ é€Ÿï¼Œ256-bit èåˆä¹˜åŠ  |
| 16 | SSE Dot Product å›é€€ | æŒ‡ä»¤çº?| SIMD | 128-bit å›é€€ï¼Œå…¨ x86-64 å…¼å®¹ |
| 17 | ARM NEON+FMLA Dot Product | æŒ‡ä»¤çº?| SIMD | 128-bit èåˆä¹˜åŠ ï¼ŒARM64 å…¨å¹³å?|
| 18 | SQRTSD ç¡¬ä»¶å¹³æ–¹æ ?| æŒ‡ä»¤çº?| ç¡¬ä»¶æŒ‡ä»¤ | æ¶ˆé™¤å‡½æ•°è°ƒç”¨å¼€é”€ |
| 19 | è¿è¡Œæ—?CPU ç‰¹æ€§æ£€æµ?| æŒ‡ä»¤çº?| è‡ªé€‚åº” | CPUID å¤šçº§è‡ªåŠ¨é€‰æ‹©æœ€å¿«è·¯å¾?|
| 20 | ç‹¬ç«‹æ¨¡å—åŒ–å°è£?| æ¶æ„ | å¯å¤ç”?| sqlite-vec ç‹¬ç«‹ Go module |

---

## å…­ã€æŒ‡ä»¤çº§ä¼˜åŒ–ï¼šAVX-512 / AVX2 / SSE / ARM NEON SIMD åŠ é€?

### 6.1 æ¶æ„è®¾è®¡

**æ–‡ä»¶ï¼?*
- `internal/vectorstore/simd_amd64.s` â€?Plan 9 æ±‡ç¼–å®ç°ï¼ˆAVX-512 + AVX2 + SSEï¼?
- `internal/vectorstore/simd_amd64.go` â€?Go å£°æ˜ + è¿è¡Œæ—?CPU ç‰¹æ€§æ£€æµ‹ï¼ˆx86-64ï¼?
- `internal/vectorstore/simd_arm64.s` â€?Plan 9 æ±‡ç¼–å®ç°ï¼ˆARM NEON + FMLAï¼?
- `internal/vectorstore/simd_arm64.go` â€?Go å£°æ˜ï¼ˆarm64ï¼?
- `internal/vectorstore/simd_generic.go` â€?é?amd64/arm64 å¹³å°å›é€€åˆ°çº¯ Go
- `internal/vectorstore/simd_test.go` â€?æ­£ç¡®æ€§æµ‹è¯?+ æ€§èƒ½åŸºå‡†æµ‹è¯•

**è®¾è®¡åŸåˆ™ï¼?*
- è¿è¡Œæ—¶è‡ªåŠ¨æ£€æµ?CPU æ”¯æŒçš„æœ€é«˜æŒ‡ä»¤é›†ï¼ŒæŒ‰å¹³å°åˆ†å‘
- é€šè¿‡ Go build tagsï¼ˆ`//go:build amd64` / `//go:build arm64` / `//go:build !amd64 && !arm64`ï¼‰å®ç°è·¨å¹³å°ç¼–è¯‘
- x86-64 ä½¿ç”¨ `golang.org/x/sys/cpu` è¿›è¡Œ CPUID ç‰¹æ€§æ£€æµ‹ï¼Œä»…åœ¨ init æ—¶æ£€æµ‹ä¸€æ¬?
- ARM64 NEON æ˜¯åŸºçº¿æŒ‡ä»¤é›†ï¼Œæ— éœ€è¿è¡Œæ—¶æ£€æµ?

```
x86-64 åˆ†å‘:
  AVX-512 (nâ‰?4) â†?AVX2+FMA (nâ‰?2) â†?SSE (nâ‰?6) â†?Pure Go

ARM64 åˆ†å‘:
  NEON+FMLA (nâ‰?6) â†?Pure Go
```

```go
// x86-64
var (
    hasAVX512 = cpu.X86.HasAVX512F
    hasAVX2   = cpu.X86.HasAVX2 && cpu.X86.HasFMA
)

func dotProductSIMD(a, b []float32) float32 {
    if hasAVX512 && n >= 64 { return dotProductAVX512(a, b) }
    if hasAVX2 && n >= 32   { return dotProductAVX2(a, b) }
    if n >= 16              { return dotProductSSE(a, b) }
    return dotProductF32x8(a, b)
}

// ARM64
func dotProductSIMD(a, b []float32) float32 {
    if n >= 16 { return dotProductNEON(a, b) }
    return dotProductF32x8(a, b)
}
```

### 6.2 AVX-512 å®ç°

**æŒ‡ä»¤é›†ï¼š** AVX-512Fï¼?12-bit ZMM å¯„å­˜å™¨ï¼‰+ FMA

**æ ¸å¿ƒå¾ªç¯ï¼?* æ¯æ¬¡è¿­ä»£å¤„ç† 64 ä¸?float32ï¼?56 å­—èŠ‚ï¼‰ï¼Œä½¿ç”¨ 4 ä¸?ZMM ç´¯åŠ å™¨ï¼ˆZ0-Z3ï¼‰ï¼Œæ¯ä¸ª ZMM å¯„å­˜å™¨å®¹çº?16 ä¸?float32ï¼Œæ˜¯ YMM çš?2 å€å®½åº¦ã€?

```asm
avx512_loop64:
    VMOVUPS 0(SI), Z4           // åŠ è½½ a[i:i+16]    (64 å­—èŠ‚)
    VMOVUPS 0(DI), Z5           // åŠ è½½ b[i:i+16]
    VFMADD231PS Z4, Z5, Z0     // Z0 += Z4 * Z5

    VMOVUPS 64(SI), Z6          // åŠ è½½ a[i+16:i+32]
    VMOVUPS 64(DI), Z7
    VFMADD231PS Z6, Z7, Z1     // Z1 += Z6 * Z7

    VMOVUPS 128(SI), Z4         // åŠ è½½ a[i+32:i+48]
    VMOVUPS 128(DI), Z5
    VFMADD231PS Z4, Z5, Z2

    VMOVUPS 192(SI), Z6         // åŠ è½½ a[i+48:i+64]
    VMOVUPS 192(DI), Z7
    VFMADD231PS Z6, Z7, Z3
```

**å…³é”®æŠ€æœ¯ç‚¹ï¼?*

1. **512-bit ZMM å¯„å­˜å™¨ï¼š** æ¯æ¡æŒ‡ä»¤å¤„ç† 16 ä¸?float32ï¼ˆvs AVX2 çš?8 ä¸ªï¼‰ï¼Œç†è®ºååé‡ç¿»å€?

2. **4 è·?ZMM ç´¯åŠ å™¨ï¼ˆZ0-Z3ï¼‰ï¼š** ä¸?AVX2 ç›¸åŒçš„ç´¯åŠ å™¨ç­–ç•¥ï¼Œä½†æ¯è·¯å®½åº¦ç¿»å€ã€?4 floats/iter = 4 Ã— 16ï¼?536 ç»´å‘é‡ä»…éœ€ 24 æ¬¡è¿­ä»£ï¼ˆvs AVX2 çš?48 æ¬¡ï¼‰

3. **å¤šçº§å°¾éƒ¨å¤„ç†ï¼?* ä¸»å¾ªç¯åä¾æ¬¡å¤„ç† 32 floatsï¼? Ã— ZMMï¼‰ã€?6 floatsï¼? Ã— ZMMï¼‰ã€é€å…ƒç´ æ ‡é‡å°¾éƒ¨ï¼Œç¡®ä¿ä»»æ„é•¿åº¦å‘é‡çš„æ­£ç¡®æ€?

4. **æ°´å¹³å½’çº¦ï¼?* ä½¿ç”¨ `VEXTRACTF64X4` å°?512-bit ZMM æ‹†åˆ†ä¸ºä¸¤ä¸?256-bit YMMï¼Œç„¶åå¤ç”?AVX2 çš„å½’çº¦è·¯å¾„ï¼ˆ`VEXTRACTF128` â†?`VMOVHLPS` â†?`VPSHUFD` â†?`VADDSS`ï¼?

5. **VZEROUPPERï¼?* è¿”å›å‰æ¸…é™?YMM/ZMM é«˜ä½ï¼Œé¿å…?SSE è½¬æ¢æƒ©ç½š

**ä¸?AVX2 çš„å¯¹æ¯”ï¼š**

| ç‰¹æ€?| AVX-512 | AVX2 |
|------|---------|------|
| å¯„å­˜å™¨å®½åº?| 512-bit (ZMM) | 256-bit (YMM) |
| æ¯æ¡æŒ‡ä»¤å¤„ç† | 16 floats | 8 floats |
| æ¯æ¬¡è¿­ä»£å¤„ç† | 64 floats (256B) | 32 floats (128B) |
| 1536 ç»´è¿­ä»£æ¬¡æ•?| 24 æ¬?| 48 æ¬?|
| ç†è®ºåŠ é€Ÿæ¯” (vs AVX2) | ~2x | åŸºå‡† |
| CPU æ”¯æŒ | Intel Xeon (Skylake-SP+), Ice Lake+, Zen 4+ | Haswell+ (2013), Zen+ (2018) |

**é€‚ç”¨åœºæ™¯ï¼?* Intel Xeon æœåŠ¡å™¨ï¼ˆSkylake-SPã€Cascade Lakeã€Ice Lakeï¼‰ã€Intel 11 ä»? æ¡Œé¢ CPUã€AMD Zen 4+ å¤„ç†å™¨ã€‚åœ¨è¿™äº›å¹³å°ä¸Šï¼ŒAVX-512 å¯ä»¥å°?dot product æ€§èƒ½åœ?AVX2 åŸºç¡€ä¸Šå†æå‡çº?2 å€ã€?

> **æ³¨æ„ï¼?* éƒ¨åˆ† CPUï¼ˆå¦‚ AMD Zen 4ï¼‰çš„ AVX-512 å®é™…ä»?256-bit åŒå‘å°„å®ç°ï¼ŒåŠ é€Ÿæ¯”å¯èƒ½ä½äºç†è®ºå€¼ã€‚Intel Alder Lake ç­‰æ··åˆæ¶æ?CPU å¯èƒ½ä¸æ”¯æŒ?AVX-512ã€‚è¿è¡Œæ—¶ CPUID æ£€æµ‹ç¡®ä¿åªåœ¨çœŸæ­£æ”¯æŒçš„ç¡¬ä»¶ä¸Šå¯ç”¨ã€?

### 6.3 AVX2 + FMA å®ç°

**æŒ‡ä»¤é›†ï¼š** AVX2ï¼?56-bit å¯„å­˜å™¨ï¼‰+ FMAï¼ˆèåˆä¹˜åŠ ï¼‰

**æ ¸å¿ƒå¾ªç¯ï¼?* æ¯æ¬¡è¿­ä»£å¤„ç† 32 ä¸?float32ï¼?28 å­—èŠ‚ï¼‰ï¼Œä½¿ç”¨ 4 ä¸?YMM ç´¯åŠ å™¨æœ€å¤§åŒ–ååã€?

```asm
avx2_loop32:
    VMOVUPS 0(SI), Y4           // åŠ è½½ a[i:i+8]
    VMOVUPS 0(DI), Y5           // åŠ è½½ b[i:i+8]
    VFMADD231PS Y4, Y5, Y0     // Y0 += Y4 * Y5 (èåˆä¹˜åŠ ï¼Œå•æŒ‡ä»¤)

    VMOVUPS 32(SI), Y6          // åŠ è½½ a[i+8:i+16]
    VMOVUPS 32(DI), Y7
    VFMADD231PS Y6, Y7, Y1     // Y1 += Y6 * Y7

    VMOVUPS 64(SI), Y4          // åŠ è½½ a[i+16:i+24]
    VMOVUPS 64(DI), Y5
    VFMADD231PS Y4, Y5, Y2

    VMOVUPS 96(SI), Y6          // åŠ è½½ a[i+24:i+32]
    VMOVUPS 96(DI), Y7
    VFMADD231PS Y6, Y7, Y3
```

**å…³é”®æŠ€æœ¯ç‚¹ï¼?*

1. **VFMADD231PSï¼ˆèåˆä¹˜åŠ ï¼‰ï¼?* å°†ä¹˜æ³•å’ŒåŠ æ³•åˆå¹¶ä¸ºå•æ¡æŒ‡ä»¤ï¼Œå‡å°‘ä¸€åŠçš„æµ®ç‚¹è¿ç®—æŒ‡ä»¤æ•°ï¼ŒåŒæ—¶æé«˜ç²¾åº¦ï¼ˆä¸­é—´ç»“æœä¸æˆªæ–­ï¼?

2. **4 è·?YMM ç´¯åŠ å™¨ï¼ˆY0-Y3ï¼‰ï¼š** æ¶ˆé™¤å†™åè¯»ä¾èµ–ï¼ˆWAR dependencyï¼‰ï¼Œè®?CPU çš„å¤šä¸ªæ‰§è¡Œç«¯å£å¯ä»¥åŒæ—¶å¤„ç†ä¸åŒçš„ FMA æŒ‡ä»¤ã€‚ç°ä»?CPU é€šå¸¸æœ?2 ä¸?FMA æ‰§è¡Œå•å…ƒï¼? è·¯ç´¯åŠ å™¨ç¡®ä¿æµæ°´çº¿å§‹ç»ˆæ»¡è½?

3. **VMOVUPSï¼ˆéå¯¹é½åŠ è½½ï¼‰ï¼š** Go çš?slice ä¸ä¿è¯?32 å­—èŠ‚å¯¹é½ï¼Œä½¿ç”¨éå¯¹é½åŠ è½½æŒ‡ä»¤é¿å…æ®µé”™è¯¯ã€‚ç°ä»?CPU ä¸Šéå¯¹é½åŠ è½½çš„æ€§èƒ½æƒ©ç½šå·²ç»å¾ˆå°

4. **æ°´å¹³å½’çº¦ï¼?* ä½¿ç”¨ `VEXTRACTF128` + `VADDPS` + `VMOVHLPS` + `VPSHUFD` å°?8 ä¸?float32 å½’çº¦ä¸?1 ä¸ªæ ‡é‡ç»“æ?

5. **VZEROUPPERï¼?* åœ¨è¿”å›å‰æ¸…é™¤ YMM å¯„å­˜å™¨é«˜ 128 ä½ï¼Œé¿å… AVX-SSE è½¬æ¢æƒ©ç½šï¼ˆIntel CPU ä¸Šå¯èƒ½å¯¼è‡´æ•°ç™¾å‘¨æœŸçš„æ€§èƒ½æŸå¤±ï¼?

### 6.4 SSE å›é€€å®ç°

**æŒ‡ä»¤é›†ï¼š** SSEï¼?28-bit XMM å¯„å­˜å™¨ï¼‰ï¼Œæ‰€æœ?x86-64 CPU å‡æ”¯æŒ?

**æ ¸å¿ƒå¾ªç¯ï¼?* æ¯æ¬¡è¿­ä»£å¤„ç† 16 ä¸?float32ï¼?4 å­—èŠ‚ï¼‰ï¼Œä½¿ç”¨ 4 ä¸?XMM ç´¯åŠ å™¨ã€?

```asm
sse_loop16:
    MOVUPS  0(SI), X4
    MOVUPS  0(DI), X5
    MULPS   X5, X4              // X4 = a[i:i+4] * b[i:i+4]
    ADDPS   X4, X0              // X0 += X4

    MOVUPS  16(SI), X6
    MOVUPS  16(DI), X7
    MULPS   X7, X6
    ADDPS   X6, X1
    // ... X2, X3
```

**ä¸?AVX2 çš„åŒºåˆ«ï¼š**
- 128-bit å¯„å­˜å™¨ï¼ˆ4 ä¸?float32 vs 8 ä¸ªï¼‰
- æ—?FMAï¼Œéœ€è¦åˆ†å¼€çš?MULPS + ADDPSï¼? æ¡æŒ‡ä»?vs 1 æ¡ï¼‰
- ååé‡çº¦ä¸?AVX2 çš?1/4

### 6.5 ARM64 NEON + FMLA å®ç°

**æŒ‡ä»¤é›†ï¼š** ARM NEONï¼?28-bit å‘é‡å¯„å­˜å™¨ï¼‰+ FMLAï¼ˆèåˆä¹˜åŠ ï¼‰

**æ–‡ä»¶ï¼?* `internal/vectorstore/simd_arm64.s`

**æ ¸å¿ƒå¾ªç¯ï¼?* æ¯æ¬¡è¿­ä»£å¤„ç† 16 ä¸?float32ï¼?4 å­—èŠ‚ï¼‰ï¼Œä½¿ç”¨ 4 ä¸?NEON ç´¯åŠ å™¨ï¼ˆV0-V3ï¼‰ï¼Œæ¯ä¸ªå¯„å­˜å™¨å®¹çº?4 ä¸?float32ã€?

```asm
neon_loop16:
    VLD1.P  16(R0), [V4.S4]       // åŠ è½½ a[i:i+4]
    VLD1.P  16(R2), [V5.S4]       // åŠ è½½ b[i:i+4]
    VFMLA   V4.S4, V5.S4, V0.S4   // V0 += V4 * V5 (èåˆä¹˜åŠ )

    VLD1.P  16(R0), [V6.S4]
    VLD1.P  16(R2), [V7.S4]
    VFMLA   V6.S4, V7.S4, V1.S4

    VLD1.P  16(R0), [V4.S4]
    VLD1.P  16(R2), [V5.S4]
    VFMLA   V4.S4, V5.S4, V2.S4

    VLD1.P  16(R0), [V6.S4]
    VLD1.P  16(R2), [V7.S4]
    VFMLA   V6.S4, V7.S4, V3.S4
```

**å…³é”®æŠ€æœ¯ç‚¹ï¼?*

1. **VFMLAï¼ˆèåˆä¹˜åŠ ï¼‰ï¼?* ARM ç­‰ä»·äº?x86 çš?VFMADD231PSï¼Œå•æ¡æŒ‡ä»¤å®Œæˆä¹˜åŠ ï¼Œæ‰€æœ?ARMv8 CPU å‡æ”¯æŒ?

2. **4 è·¯ç´¯åŠ å™¨ï¼ˆV0-V3ï¼‰ï¼š** ä¸?x86 å®ç°ç›¸åŒçš„ç­–ç•¥ï¼Œæ¶ˆé™¤å¾ªç¯æºå¸¦ä¾èµ–

3. **VLD1.Pï¼ˆåé€’å¢åŠ è½½ï¼‰ï¼š** åŠ è½½æ•°æ®çš„åŒæ—¶è‡ªåŠ¨é€’å¢æŒ‡é’ˆï¼Œå‡å°‘ä¸€æ?ADD æŒ‡ä»¤

4. **æ°´å¹³å½’çº¦ï¼?* ä½¿ç”¨ `VEXT` æ—‹è½¬ + `VADD` é€æ­¥å°?4 ä¸?float32 å½’çº¦ä¸ºæ ‡é‡?

5. **å¤šçº§å°¾éƒ¨å¤„ç†ï¼?* ä¸»å¾ªç¯åä¾æ¬¡å¤„ç† 8 floatsã€? floatsã€é€å…ƒç´ æ ‡é‡å°¾éƒ¨ï¼ˆ`FMADDS`ï¼?

**é€‚ç”¨åœºæ™¯ï¼?* Apple Silicon (M1/M2/M3/M4)ã€AWS Gravitonã€æ ‘è“æ´¾ 4+ã€æ‰€æœ?ARMv8-A å¤„ç†å™¨ã€‚NEON æ˜?ARM64 çš„åŸºçº¿æŒ‡ä»¤é›†ï¼Œæ— éœ€è¿è¡Œæ—¶æ£€æµ‹ã€?

**ä¸?x86 SSE çš„å¯¹æ¯”ï¼š**

| ç‰¹æ€?| ARM NEON | x86 SSE |
|------|----------|---------|
| å¯„å­˜å™¨å®½åº?| 128-bit | 128-bit |
| æ¯æ¡æŒ‡ä»¤å¤„ç† | 4 floats | 4 floats |
| èåˆä¹˜åŠ  | VFMLAï¼ˆåŸºçº¿æ”¯æŒï¼‰ | æ— ï¼ˆéœ€ MULPS+ADDPS ä¸¤æ¡ï¼?|
| æ¯æ¬¡è¿­ä»£å¤„ç† | 16 floats | 16 floats |
| åé€’å¢å¯»å€ | VLD1.Pï¼ˆå†…ç½®ï¼‰ | éœ€é¢å¤– ADD æŒ‡ä»¤ |

### 6.6 SQRTSD ç¡¬ä»¶å¹³æ–¹æ ?

**é—®é¢˜ï¼?* `math.Sqrt` é€šè¿‡å‡½æ•°è°ƒç”¨å®ç°ï¼Œæœ‰è°ƒç”¨å¼€é”€ã€?

**æ–¹æ¡ˆï¼?* ç›´æ¥åœ¨æ±‡ç¼–ä¸­ä½¿ç”¨ `SQRTSD` æŒ‡ä»¤ï¼Œå•æ¡æŒ‡ä»¤å®Œæˆ?float64 å¹³æ–¹æ ¹è®¡ç®—ã€?

```asm
TEXT Â·sqrtAsm(SB), NOSPLIT, $0-16
    MOVSD   x+0(FP), X0
    SQRTSD  X0, X0
    MOVSD   X0, ret+8(FP)
    RET
```

### 6.7 å®æµ‹ Benchmark ç»“æœ

æµ‹è¯•ç¯å¢ƒï¼šAMD Ryzen 7 7840H, Windows, Go 1.25.5

#### Dot Product æ€§èƒ½å¯¹æ¯”

| å‘é‡ç»´åº¦ | Pure Go (8-way å±•å¼€) | AVX2+FMA | AVX-512 | åŠ é€Ÿæ¯” (AVX-512 vs Go) |
|---------|---------------------|----------|---------|----------------------|
| 768 ç»?| 309 ns/op | 36 ns/op | 34.6 ns/op | **8.9x** |
| 1536 ç»?| 593 ns/op | 70.7 ns/op | 67.3 ns/op | **8.8x** |
| 3072 ç»?| 1162 ns/op | 135 ns/op | 128.9 ns/op | **9.0x** |

> **AMD Zen 4 AVX-512 ç‰¹æ€§ï¼š** Ryzen 7 7840H (Zen 4) æ”¯æŒ AVX-512ï¼Œä½†ä»?256-bit åŒå‘å°„æ–¹å¼å®ç°ï¼Œå› æ­¤ AVX-512 ä¸?AVX2 æ€§èƒ½æ¥è¿‘ï¼ˆ~5% æå‡ï¼‰ã€‚åœ¨åŸç”Ÿ 512-bit æ‰§è¡Œå•å…ƒçš?Intel Xeon (Ice Lake+) ä¸Šï¼ŒAVX-512 é¢„æœŸå¯è·å¾—æ›´æ˜¾è‘—çš„åŠ é€Ÿï¼ˆ~1.5-2x vs AVX2ï¼‰ã€?

#### Norm è®¡ç®—æ€§èƒ½å¯¹æ¯”

| å‘é‡ç»´åº¦ | Pure Go (8-way å±•å¼€) | SIMD (AVX2 dot + SQRTSD) | åŠ é€Ÿæ¯” |
|---------|---------------------|--------------------------|--------|
| 1536 ç»?| 437 ns/op | 77 ns/op | **5.7x** |

#### ç«¯åˆ°ç«¯æœç´¢å½±å“ä¼°ç®?

ä»?10K chunks Ã— 1536 ç»´ä¸ºä¾‹ï¼Œå•æ¬¡æœç´¢éœ€è¦?10K æ¬?dot productï¼?

| é˜¶æ®µ | Pure Go | AVX2 SIMD | AVX-512 | èŠ‚çœ (AVX-512) |
|------|---------|-----------|---------|---------------|
| 10K æ¬?dot product | 5.93 ms | 0.71 ms | 0.67 ms | 5.26 ms |
| åŠ ä¸Š product åˆ†åŒºï¼ˆå‡è®?50% è¿‡æ»¤ï¼?| 2.97 ms | 0.35 ms | 0.34 ms | 2.63 ms |
| åŠ ä¸Š LRU ç¼“å­˜å‘½ä¸­ | 0 ms | 0 ms | 0 ms | â€?|

### 6.8 å¤šå¹³å°å›é€€ç­–ç•¥

```
x86-64 (simd_amd64.s):
  dotProductSIMD()
    â”œâ”€â”€ hasAVX512 && len >= 64 â†?dotProductAVX512()   // æé€Ÿï¼š512-bit FMA, 64 floats/iter
    â”œâ”€â”€ hasAVX2 && len >= 32   â†?dotProductAVX2()     // å¿«é€Ÿï¼š256-bit FMA, 32 floats/iter
    â”œâ”€â”€ len >= 16              â†?dotProductSSE()       // ä¸­ç­‰ï¼?28-bit MULPS+ADDPS
    â””â”€â”€ else                   â†?dotProductF32x8()     // å›é€€ï¼šçº¯ Go 8-way å±•å¼€

ARM64 (simd_arm64.s):
  dotProductSIMD()
    â”œâ”€â”€ len >= 16              â†?dotProductNEON()      // NEON+FMLA, 16 floats/iter
    â””â”€â”€ else                   â†?dotProductF32x8()     // å›é€€ï¼šçº¯ Go 8-way å±•å¼€

å…¶ä»–å¹³å° (simd_generic.go):
  dotProductSIMD() â†?dotProductF32x8()                 // çº?Go 8-way å±•å¼€
```

- **AVX-512 è·¯å¾„ï¼?* Intel Xeon (Skylake-SP+)ã€Intel 11 ä»? æ¡Œé¢ CPUã€AMD Zen 4+
- **AVX2+FMA è·¯å¾„ï¼?* Intel Haswell+ (2013)ã€AMD Zen+ (2018)
- **SSE è·¯å¾„ï¼?* æ‰€æœ?x86-64 CPUï¼ˆSSE2 æ˜?amd64 åŸºçº¿ï¼?
- **NEON è·¯å¾„ï¼?* æ‰€æœ?ARM64 CPUï¼ˆApple Siliconã€Gravitonã€æ ‘è“æ´¾ 4+ï¼?
- **çº?Go è·¯å¾„ï¼?* 32-bit ARMã€MIPSã€RISC-V ç­‰ï¼Œä»¥åŠæçŸ­å‘é‡

### 6.9 æ­£ç¡®æ€§ä¿è¯?

- `TestSIMDCapability` éªŒè¯è¿è¡Œæ—?SIMD æ£€æµ‹æ­£ç¡®æŠ¥å‘Šå½“å‰?CPU èƒ½åŠ›
- ç«¯åˆ°ç«?Search æµ‹è¯•ï¼ˆ`TestSearchReturnsTopK`ã€`TestSearchSortedDescending` ç­‰ï¼‰éšå¼è¦†ç›– SIMD dot product çš„æ­£ç¡®æ€?
- `dotProductSIMD()` è‡ªåŠ¨é€‰æ‹©å½“å‰ CPU æ”¯æŒçš„æœ€é«˜æŒ‡ä»¤é›†ï¼Œæ‰€æœ‰æœç´¢æµ‹è¯•å‡é€šè¿‡ SIMD è·¯å¾„æ‰§è¡Œ
- ç«¯åˆ°ç«?Benchmarkï¼ˆ`BenchmarkSearch_1000x1536`ã€`BenchmarkSearch_5000x1536`ã€`BenchmarkSearch_10000x768`ï¼‰éªŒè¯ä¸åŒæ•°æ®è§„æ¨¡ä¸‹çš„æ€§èƒ½

---

## ä¸ƒã€æ¶‰åŠæ–‡ä»¶æ¸…å?

| æ–‡ä»¶è·¯å¾„ | ç”¨é€?| ä¼˜åŒ–é¡?|
|---------|------|-------|
| `internal/vectorstore/store.go` | å‘é‡å­˜å‚¨ä¸æœç´¢æ ¸å¿?| #1-#9, #13 |
| `internal/vectorstore/serialize.go` | å‘é‡åºåˆ—åŒ?ååºåˆ—åŒ– | #2, #12 |
| `internal/vectorstore/simd_amd64.s` | AVX-512/AVX2/SSE Plan 9 æ±‡ç¼– | #14, #15, #16, #18 |
| `internal/vectorstore/simd_amd64.go` | SIMD Go å£°æ˜ + CPU æ£€æµ?(x86-64) | #14, #15, #19 |
| `internal/vectorstore/simd_arm64.s` | ARM NEON Plan 9 æ±‡ç¼– | #17 |
| `internal/vectorstore/simd_arm64.go` | SIMD Go å£°æ˜ (arm64) | #17 |
| `internal/vectorstore/simd_generic.go` | é?x86/arm64 å¹³å°çº?Go å›é€€ | #16 |
| `internal/vectorstore/simd_test.go` | SIMD æ­£ç¡®æ€?+ åŸºå‡†æµ‹è¯• | #14, #15, #16, #17 |
| `internal/query/engine.go` | RAG æŸ¥è¯¢å¼•æ“ | #10, #11 |

### ç‹¬ç«‹æ¨¡å—

å…¨éƒ¨ä¼˜åŒ–å·²æå–ä¸ºç‹¬ç«‹ Go module `github.com/nicexipi/sqlite-vec`ï¼ˆ`sqlite-vec/` ç›®å½•ï¼‰ï¼Œå¯åœ¨å…¶ä»–é¡¹ç›®ä¸­ç›´æ¥å¼•ç”¨ã€‚æ¨¡å—åŒ…å«å®Œæ•´çš„å‘é‡å­˜å‚¨ã€SIMD åŠ é€Ÿã€åºåˆ—åŒ–ç­‰åŠŸèƒ½ï¼Œä½¿ç”¨ `partitionID` æ›¿ä»£ `productID` å®ç°æ›´é€šç”¨çš„åˆ†åŒºè¯­ä¹‰ã€?

| æ–‡ä»¶è·¯å¾„ | ç”¨é€?|
|---------|------|
| `sqlite-vec/store.go` | ç‹¬ç«‹æ¨¡å—ä¸»æ–‡ä»¶ï¼ŒåŒ…å«å…¨éƒ¨å­˜å‚¨å±‚ä¼˜åŒ?|
| `sqlite-vec/serialize.go` | åºåˆ—åŒ?ååºåˆ—åŒ– |
| `sqlite-vec/simd_amd64.go` | x86-64 SIMD å£°æ˜ + CPU æ£€æµ?|
| `sqlite-vec/simd_arm64.go` | ARM64 NEON å£°æ˜ |
| `sqlite-vec/go.mod` | æ¨¡å—å®šä¹‰ (`github.com/nicexipi/sqlite-vec`) |

### ä¾èµ–å˜æ›´

| ä¾èµ– | ç”¨é€?|
|------|------|
| `golang.org/x/sys/cpu` | è¿è¡Œæ—?CPUID ç‰¹æ€§æ£€æµ‹ï¼ˆAVX-512F / AVX2 / FMAï¼?|
